<!DOCTYPE html>

<!-- SLIDE
    Moose

    Authors: Damien 'dams' Krotkine
    http://dams.github.com
    -->


<html>
  <head>
    <title>Moose</title>
    <meta charset='utf-8'/>
    <script src='lib/slides.js'></script>
    <link rel="icon" type="image/png" href="images/logo.png" />
  </head>
  
  <style>
      .slides.template-default > article:not(.nobackground):not(.biglogo) {
          background: url(images/logo.png) 710px 625px no-repeat !important;
          background-position: right bottom !important;
          background-color: white !important;
      }
      .slides.template-default article p.smaller,span.smaller {
          font-size: 20px;
          line-height: 24px;
          letter-spacing: 0;
      }
      div.centered, ul.centered {
          padding-top: 150px;
      }

  </style>

  <body style='display: none'>

    <section class='slides layout-regular template-default'>
<!--   <section class='slides layout-widescreen template-default'> -->



<article>
    <h1>
        Moose
    </h1>
    <p>
        Damien Krotkine (<em>dams</em>)
        <br/>
        <br/>
        Mar 05, 2012
    </p>
</article>



<article>
<h1> </h1>
    <img src="images/bears.png" style="float: right; margin: 10px;">
<h2> Sponsor de la soirée : Bearstech</h2>
<p>
<ul>
    <li>Merci à eux</li>
</ul>
</p>
</article>




<article>
<h1> </h1>
<h2> Damien Krotkine</h2>
<p>
    <img src="images/me.png" style="float: right; margin: 10px;">
<ul>
    <li>vice-président des <em>Mongueurs de Perl</em></li>
    <li><em>blog</em> : dams.github.com</li>
    <li><em>CPAN</em> : metacpan.org/author/DAMS</li>
    <li><em>github</em> : github.com/dams</li>
</ul>
</p>
</article>



<article class="fill">
    <h3>
        Moose ?
    </h3>
    <p>
    <img src="images/moose.jpg">
    </p>
    <h3 style="position: absolute; bottom: 10px;">
          <center>A postmodern metaclass-based object system for Perl 5</center>
    </h3>
</article>



<article>
<h2> L'objet <em>old-school</em> </h2>
<br/>
<div id="wrap" style="width:100%; margin:0 auto;">
<div id="left-side" style="float:left;width:48%;">
<ul class="build">
<li> un hash <em>bless</em>-é :
<pre>bless {}, __PACKAGE__;</pre>
</li>
<li> méthode <em>new</em> à la main :
<pre>
sub new {
  my ( $class, @args ) = @_;

  # params
  my $self = { @args };
  bless $self, $class;
  return $self;
}</pre>
</li></ul>
</div>
<div id="right-side" style="float:right;width:48%;">
<ul class="build">
<li> pas de vrais attributs :
<pre>
sub name {
  my ( $self, $name ) = @_;
  $name and
    $self->{'name'} = $name;
  return $self->{'name'};
}
</pre>
</li>
</ul>
</div>
</div>
</article>



<article>
<h2> Pourquoi utiliser Moose ?</h2>
<div id="wrap" style="width:100%; margin:0 auto;">
<div id="left-side" style="float:left;width:48%;">
<p><ul class="build">
  <li>Old-school
<pre style="font-size:10px; line-height:120%; ">
package Person;

use strict;
use warnings;

use Carp qw( confess );
use DateTime;
use DateTime::Format::Natural;


sub new {
    my $class = shift;
    my %p = ref $_[0] ? %{ $_[0] } : @_;

    exists $p{name}
        or confess 'name is a required attribute';
    $class->_validate_name( $p{name} );

    exists $p{birth_date}
        or confess 'birth_date is a required attribute';

    $p{birth_date} = $class->_coerce_birth_date( $p{birth_date} );
    $class->_validate_birth_date( $p{birth_date} );

    return bless \%p, $class;
}

sub _validate_name {
    shift;
    my $name = shift;

    local $Carp::CarpLevel = $Carp::CarpLevel + 1;

    defined $name
        or confess 'name must be a string';
}

sub _validate_birth_date { ... }
...
</li></ul></p></pre>
</div>

<div id="right-side" style="float:right;width:50%;">
<p><ul class="build">
  <li>avec Moose
<pre>
package Person;

use Moose;

has name => (
    is       => 'rw',
    isa      => 'Str',
    required => 1 );

has birth_date => (
    is       => 'rw',
    isa      => 'DateTime',
);
</li></ul></p></pre>
</div>
</div>
</article>



<article>
    <h1>
        Une classe
    </h1>
</article>


<article>
<h2> Définir une classe avec Moose</h2>
<pre>
package Person;
use Moose;

</pre>

<h3>On obtient</h3>
<p>
<ul>
    <li>une classe <code>Person</code> !</li>
</ul>
</p>
<pre>
use Person;
my $person = Person->new();
</pre>
<p>
<ul>
  <li><code>use strict</code></li>
  <li><code>use warnings</code></li>
</ul></p>
</article>




<article>
    <h1>
        Les attributs
    </h1>
</article>




<article>
<h2> Déclarer un attribut</h2>

<pre>
package Person;
use Moose;
has name => (
  is => 'rw',
);
</pre>

<pre>
use Person;
my $person = Person->new();
$person->name('Jean');
say $person->name();
</pre>

<p>
<ul>
    <li>il existe<code>'ro'</code> pour <em>read-only</em></li>
    <li>génère automatiquement l'accesseur <code>name()</code></li>
    <li>plus d'options (vu par la suite)</li>
</ul>

</article>





<article>
<h2> Le typage</h2>

<pre>
package Person;
use Moose;
has name => (
  is => 'rw',
  isa => 'Str',
);
</pre>

<p>
<ul>
    <li>permet le <em>typage</em> des attributs</li>
    <li>beaucoup de types (Str, Int, ArrayRef, HashRef...)</li>
    <li>soit un type, soit un nom de classe</li>
    <li>on peut <em>combiner</em> les types : <code>ArrayRef[Str], HashRef[ArrayRef[Str]]</code></li>
    <li>les types ont de l'héritage : <code>Int</code> hérite de <code>Num</code>
</ul>

</article>





<article>
<h2> L'arbre de types</h2>
<pre style="font-size:18px; line-height:120%; ">
Any
Item
    Bool
    Maybe[a]
    Undef
    Defined
        Value
            Str
                Num
                    Int
                ClassName
                RoleName
        Ref
            ScalarRef[a]
            ArrayRef[a]
            HashRef[a]
            CodeRef
            RegexpRef
            GlobRef
                FileHandle
            Object
</pre>
</article>



<article>
    <h1>
        Les méthodes
    </h1>
</article>

<article>
<h2> Les méthodes</h2>

<pre>
package Person;
use Moose;
sub speak {
  my ($self, $text) = @_;
  say $self->name . ' is saying: ' . $text;
}
</pre>

<pre>
use Person;
my $person = Person->new(name => 'Jean');
$person->speak('Hello');
</pre>
</article>



<article>
    <h1>
        L'héritage
    </h1>
</article>




<article>
<h2> L'héritage</h2>

<pre>
package Punk;
use Moose;
extends 'Person';
</pre>
<p>L'héritage multiple est possible</p>
<pre>
package Child;
use Moose;
extends 'Father', 'Mother;
</pre>

</article>





<article>
    <h1>
        Les rôles
    </h1>
</article>





<article>
<h2> Les rôles</h2>

<pre>
package Punk;
use Moose;
extends 'Person';
with 'Piercings';
</pre>
<p>Il est recommandé d'utiliser beaucoup de rôles</p>
<pre>
package Punk;
use Moose;
extends 'Person';
with 'Piercings', 'Tatoos';
</pre>

</article>



<article>
    <h1>
        Les modificateurs de méthodes
    </h1>
</article>


<article>
<h2> Les modificateurs de méthodes</h2>

<pre>
package Person::WinterAware;
use Moose;
extends 'Person';

before leaving => sub {
  my $self = shift;
  $self->take_jacket if $self->cold;
}
</pre>
<p>
<ul>
  <li><code>before</code> : exécute du code <em>avant</em>
  <li><code>after</code> : exécute du code <em>après</em>
  <li><code>around</code> : <em>encapsule</em> la méthode
</ul>
</article>




<article>
    <h1>
        Plus d'options sur les attributs
    </h1>
</article>


<article>
<h2> Plus d'options sur les attributs</h2>
<pre>
has hat => (
  is        => 'rw',
  isa       => 'Hat',
  default   => sub { Hat::Default->new },
  required  => 1,
  lazy      => 1,
  predicate => 'has_hat',
  clearer   => 'clear_hat',
  builder   => 'build_hat,
);
</pre>
</article>


<article>
<h2> <code>default</code></h2>
<pre>
default => 'chat',              # une chaîne
default => 3,                   # un nombre
default => sub {  { }  },       # un hash
default => sub {  [ ]  },       # un tableau
default => sub { Class->new },  # un Objet
</pre>
<p>Pour plus de puissance, utiliser <em>builder</em>
<p><br/></p>
<h2> <code>required</code></h2>
<pre>
required => 1  # obligatoire
required => 0  # optionel
</pre>
</article>





<article>
<h2> <code>lazy</code></h2>
<pre>
lazy => 1  # rend l'attribut fainéant
</pre>
<p>Une fois fainéant, l'attribut n'est créé qu'à la première utilisation.</p>
<p>Permet d'économiser de la mémoire, et du CPU, et de faire du chargement à la
demande.</p>
</article>




<article>
<h2> <code>clearer</code> et <code>predicate</code></h2>
<pre>
package Person;
use Moose;

has hat => (
  is => 'rw',
  clearer => 'remove_hat',
  predicate => 'has_hat',
);

sub try_to_remove_hat {
  my $self = shift;
  $self->remove_hat if $self->has_hat;
}
</pre>
<pre>
my $person = Person->new();
$person->try_to_remove_hat;
</article>

<article>
    <h1>
        Conclusion
    </h1>
</article>

<article>
<h2> Moose </h2>
<br/>
<p><ul>
<li>c'est élégant</li>
<li>stable</li>
<li>prêt pour le futur</li>
<li>beaucoup plus d'options</li>
<li>beaucoup d'extensions</li>
</ul>
</p>

<p>A découvrir sur CPAN :<br/>
http://metacpan.org/module/Moose</p>
</article>




<article class="fill">
    <h3 style="position: absolute; top: 20%;">
         Merci
    </h3>

    <p>
    <img src="images/moose2.jpg">
    </p>
</article>


    </section>

  </body>
</html>
